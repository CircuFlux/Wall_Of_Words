<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wall of Words - An Ethereal Diary</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Added new artistic fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Poppins:wght@300;400&family=Indie+Flower&family=Caveat:wght@700&family=Shadows+Into+Light&display=swap" rel="stylesheet">
    <!-- Custom Styles -->
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            background: #0f0c29;
            background: -webkit-linear-gradient(to top, #24243e, #302b63, #0f0c29);
            background: linear-gradient(to top, #24243e, #302b63, #0f0c29);
            color: #fff;
            overflow-x: hidden;
        }

        /* Font utility classes */
        .font-dancing-script { font-family: 'Dancing Script', cursive; }
        .font-indie-flower { font-family: 'Indie Flower', cursive; }
        .font-caveat { font-family: 'Caveat', cursive; }
        .font-shadows-into-light { font-family: 'Shadows Into Light', cursive; }

        .text-with-outline {
            text-shadow: 
                -1px -1px 1px rgba(0,0,0,0.4),  
                 1px -1px 1px rgba(0,0,0,0.4),
                -1px  1px 1px rgba(0,0,0,0.4),
                 1px  1px 1px rgba(0,0,0,0.4);
        }
        
        h1.font-dancing-script {
             text-shadow: 0 0 20px rgba(255, 255, 255, 0.6), 
                         -1px -1px 1px rgba(0,0,0,0.4),  
                          1px -1px 1px rgba(0,0,0,0.4),
                         -1px  1px 1px rgba(0,0,0,0.4),
                          1px  1px 1px rgba(0,0,0,0.4);
        }

        .glass-ui {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.2);
        }

        textarea::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        
        button:disabled, .like-button.liked {
            cursor: not-allowed;
            opacity: 0.6;
        }
        textarea:disabled {
            cursor: not-allowed;
        }
        .like-button:not(.liked):hover {
            transform: scale(1.1);
            opacity: 1;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        .new-paragraph {
            animation: fadeIn 0.8s ease-out;
        }
    </style>
</head>
<body class="w-full min-h-screen">

    <!-- Main Container -->
    <div class="relative container mx-auto p-4 md:p-8 max-w-7xl z-10">

        <!-- Header Section -->
        <header class="text-center mb-8 md:mb-12">
            <h1 class="font-dancing-script text-5xl md:text-7xl font-bold text-white mb-2">Wall of Words</h1>
            <p class="text-md md:text-lg text-white/80 text-with-outline">Set your thoughts free, let them drift into eternity.</p>
        </header>

        <!-- Submission Form -->
        <div class="glass-ui p-6 rounded-2xl mb-8 max-w-2xl mx-auto">
            <h2 class="font-dancing-script text-3xl font-semibold mb-4 text-white text-with-outline">Eternalize a Thought</h2>
            <textarea id="paragraphInput" class="font-dancing-script text-2xl w-full p-4 bg-transparent border-0 rounded-lg focus:ring-2 focus:ring-white/50 transition duration-200 text-white text-with-outline" rows="5" placeholder="Connecting to the wall..." disabled></textarea>
            
            <div class="flex flex-wrap justify-between items-center mt-4 gap-4">
                <!-- Font Selector -->
                <div>
                    <label for="fontSelector" class="text-sm text-white/70 text-with-outline mr-2">Font:</label>
                    <select id="fontSelector" class="bg-white/10 border border-white/30 rounded-lg text-white p-2 focus:ring-2 focus:ring-white/50 focus:outline-none">
                        <option value="font-dancing-script" class="text-black">Dancing Script</option>
                        <option value="font-indie-flower" class="text-black">Indie Flower</option>
                        <option value="font-caveat" class="text-black">Caveat</option>
                        <option value="font-shadows-into-light" class="text-black">Shadows Into Light</option>
                    </select>
                </div>
                <!-- Image Upload -->
                <div>
                    <label id="imageUploadLabel" for="bgImageInput" class="cursor-pointer inline-flex items-center px-4 py-2 border border-white/30 rounded-lg text-white/80 hover:bg-white/10 transition opacity-50">
                        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l-1.586-1.586a2 2 0 00-2.828 0L6 14m6-6l.01.01"></path></svg>
                        Add Background
                    </label>
                    <input type="file" id="bgImageInput" class="hidden" accept="image/*" disabled>
                    <span id="fileName" class="ml-4 text-sm text-white/70"></span>
                </div>
            </div>

            <div class="text-center my-4 space-y-1">
                <p class="text-xs text-white/70 italic text-with-outline">
                    Heads up: Once submitted, your words are eternalized on this public wall and cannot be edited or removed.
                </p>
                <p class="text-xs text-white/70 italic text-with-outline">
                    Your privacy matters. No personal data is collected.
                </p>
            </div>

            <button id="submitButton" class="group w-full bg-white/20 text-white font-semibold py-3 px-6 rounded-lg hover:bg-white/30 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-transparent focus:ring-white transition-all duration-300 flex items-center justify-center space-x-2" disabled>
                <span id="submitButtonText">Connecting...</span>
                <svg class="w-6 h-6 opacity-80 group-hover:opacity-100 transition-opacity" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clip-rule="evenodd"></path></svg>
            </button>
            <div id="messageBox" class="mt-4 text-center font-semibold"></div>
        </div>

        <!-- Display Area for Paragraphs -->
        <div id="paragraphsContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            <div id="loadingIndicator" class="text-center text-white/70 md:col-span-2 lg:col-span-3"><p>Loading eternal thoughts...</p></div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = {
  apiKey: "AIzaSyD5YOL4o4cFrZNMypf0kiBqhxnBYzg3mFo",
  authDomain: "wall-of-words.firebaseapp.com",
  projectId: "wall-of-words",
  storageBucket: "wall-of-words.firebasestorage.app",
  messagingSenderId: "617260153734",
  appId: "1:617260153734:web:68ba6b9196c6198452ca07",
  measurementId: "G-B2D19YBK7N"
};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : undefined;

        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, collection, addDoc, query, onSnapshot, serverTimestamp, doc, updateDoc, increment } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

        let db, auth, storage;
        try {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            storage = getStorage(app);
        } catch (error) {
            console.error("Error initializing Firebase:", error);
            const messageBox = document.getElementById('messageBox');
            if (error.message.includes("API key not valid")) {
                 messageBox.textContent = "Connection Error: Invalid Firebase keys. Please replace the placeholder keys with your project's actual keys.";
            } else {
                 messageBox.textContent = 'Error connecting to the ethereal plane.';
            }
            document.getElementById('loadingIndicator').innerText = 'Connection Failed.';
        }

        const paragraphInput = document.getElementById('paragraphInput');
        const submitButton = document.getElementById('submitButton');
        const submitButtonText = document.getElementById('submitButtonText');
        const paragraphsContainer = document.getElementById('paragraphsContainer');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const messageBox = document.getElementById('messageBox');
        const bgImageInput = document.getElementById('bgImageInput');
        const fileNameSpan = document.getElementById('fileName');
        const imageUploadLabel = document.getElementById('imageUploadLabel');
        const fontSelector = document.getElementById('fontSelector');

        // --- Local Storage for Likes ---
        function getLikedPosts() {
            return JSON.parse(localStorage.getItem('likedPosts') || '[]');
        }

        function addLikedPost(postId) {
            const likedPosts = getLikedPosts();
            if (!likedPosts.includes(postId)) {
                likedPosts.push(postId);
                localStorage.setItem('likedPosts', JSON.stringify(likedPosts));
            }
        }

        // --- Event Listeners ---
        bgImageInput.addEventListener('change', () => {
            fileNameSpan.textContent = bgImageInput.files.length > 0 ? bgImageInput.files[0].name : '';
        });

        fontSelector.addEventListener('change', (e) => {
            paragraphInput.className = `text-2xl w-full p-4 bg-transparent border-0 rounded-lg focus:ring-2 focus:ring-white/50 transition duration-200 text-white text-with-outline ${e.target.value}`;
        });

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                paragraphInput.disabled = false;
                paragraphInput.placeholder = "Write here...";
                submitButton.disabled = false;
                submitButtonText.textContent = "Submit & Eternalize";
                bgImageInput.disabled = false;
                imageUploadLabel.classList.remove('opacity-50');
                listenForParagraphs();
            } else {
                submitButtonText.textContent = "Connection Failed";
                paragraphInput.placeholder = "Could not connect. Please refresh and try again.";
                try {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } else {
                        await signInAnonymously(auth);
                    }
                } catch (error) {
                    showMessage("Could not connect to the service.", "red");
                }
            }
        });

        function listenForParagraphs() {
            const paragraphsCollectionPath = `artifacts/${appId}/public/data/paragraphs`;
            const q = query(collection(db, paragraphsCollectionPath));

            onSnapshot(q, (querySnapshot) => {
                loadingIndicator.style.display = 'none';
                paragraphsContainer.innerHTML = '';
                const paragraphs = [];
                querySnapshot.forEach((doc) => paragraphs.push({ id: doc.id, ...doc.data() }));
                paragraphs.sort((a, b) => (b.createdAt?.seconds || 0) - (a.createdAt?.seconds || 0));

                if (paragraphs.length === 0) {
                    paragraphsContainer.innerHTML = '<p class="text-center text-white/70 italic text-with-outline md:col-span-2 lg:col-span-3">The air is quiet... be the first to leave a whisper.</p>';
                } else {
                    paragraphs.forEach(para => {
                        const paragraphElement = createParagraphElement(para);
                        paragraphsContainer.appendChild(paragraphElement);
                    });
                }
            }, (error) => {
                loadingIndicator.innerText = 'Failed to load thoughts.';
                showMessage("Could not fetch data from the server.", "red");
            });
        }

        function createParagraphElement(paraData) {
            const div = document.createElement('div');
            div.className = 'glass-ui p-5 rounded-xl new-paragraph relative overflow-hidden flex flex-col';

            if (paraData.imageUrl) {
                const bgImage = document.createElement('div');
                bgImage.className = 'absolute inset-0 bg-cover bg-center';
                bgImage.style.backgroundImage = `url('${paraData.imageUrl}')`;
                bgImage.style.filter = 'blur(4px)';
                bgImage.style.transform = 'scale(1.1)';
                div.appendChild(bgImage);

                const overlay = document.createElement('div');
                overlay.className = 'absolute inset-0 bg-black/40';
                div.appendChild(overlay);
            }
            
            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'relative flex-grow';

            const p = document.createElement('p');
            p.textContent = paraData.text;
            const fontClass = paraData.fontClass || 'font-dancing-script';
            p.className = `text-2xl text-white leading-relaxed text-with-outline ${fontClass}`;
            
            contentWrapper.appendChild(p);

            const footer = document.createElement('div');
            footer.className = 'relative flex justify-between items-center mt-4';
            
            const dateSpan = document.createElement('span');
            dateSpan.className = 'text-xs text-white/60 text-with-outline';
            const date = paraData.createdAt ? paraData.createdAt.toDate().toLocaleString() : 'Just now';
            dateSpan.textContent = `Eternalized on ${date}`;

            const likeContainer = document.createElement('div');
            likeContainer.className = 'flex items-center space-x-2';

            const likeButton = document.createElement('button');
            likeButton.className = 'like-button transition-transform duration-200';
            
            const likeIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            likeIcon.setAttribute('class', 'w-6 h-6');
            likeIcon.setAttribute('viewBox', '0 0 24 24');
            likeIcon.setAttribute('stroke', 'currentColor');
            likeIcon.setAttribute('stroke-width', '1.5');
            likeIcon.innerHTML = `<path stroke-linecap="round" stroke-linejoin="round" d="M6.633 10.5c.806 0 1.533-.446 2.031-1.08a9.041 9.041 0 012.861-2.4c.723-.384 1.35-.956 1.653-1.715a4.498 4.498 0 00.322-1.672V3a.75.75 0 01.75-.75A2.25 2.25 0 0116.5 4.5c0 1.152-.26 2.243-.723 3.218-.266.558.107 1.282.725 1.282h3.126c1.026 0 1.945.694 2.054 1.715.045.422.068.85.068 1.285a11.95 11.95 0 01-2.649 7.521c-.388.482-.987.729-1.605.729H13.48c-.483 0-.964-.078-1.423-.23l-3.114-1.04a4.501 4.501 0 00-1.423-.23H5.25a2.25 2.25 0 01-2.25-2.25v-6.75a2.25 2.25 0 012.25-2.25h1.383z"></path>`;

            const likedPosts = getLikedPosts();
            if (likedPosts.includes(paraData.id)) {
                likeButton.classList.add('liked');
                likeIcon.setAttribute('fill', 'rgba(255, 255, 255, 0.8)');
            } else {
                likeIcon.setAttribute('fill', 'none');
                likeButton.onclick = () => likeParagraph(paraData.id);
            }

            const likeCount = document.createElement('span');
            likeCount.className = 'text-sm font-semibold text-with-outline';
            likeCount.textContent = paraData.likes || 0;

            likeButton.appendChild(likeIcon);
            likeContainer.appendChild(likeCount);
            likeContainer.appendChild(likeButton);
            
            footer.appendChild(dateSpan);
            footer.appendChild(likeContainer);
            
            div.appendChild(contentWrapper);
            div.appendChild(footer);
            
            return div;
        }
        
        async function likeParagraph(postId) {
            const likedPosts = getLikedPosts();
            if (likedPosts.includes(postId)) return;

            addLikedPost(postId);

            const paragraphsCollectionPath = `artifacts/${appId}/public/data/paragraphs`;
            const postRef = doc(db, paragraphsCollectionPath, postId);

            try {
                await updateDoc(postRef, {
                    likes: increment(1)
                });
            } catch (error) {
                console.error("Error liking post:", error);
            }
        }

        /**
         * FIX: New function to compress and resize an image file before upload.
         * @param {File} file - The original image file.
         * @returns {Promise<Blob>} A promise that resolves with the compressed image as a Blob.
         */
        function compressImage(file) {
            return new Promise((resolve, reject) => {
                const MAX_WIDTH = 1024; // Max width for the resized image
                const MAX_HEIGHT = 1024; // Max height for the resized image
                const MIME_TYPE = "image/jpeg";
                const QUALITY = 0.7; // Compression quality

                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        let width = img.width;
                        let height = img.height;

                        if (width > height) {
                            if (width > MAX_WIDTH) {
                                height *= MAX_WIDTH / width;
                                width = MAX_WIDTH;
                            }
                        } else {
                            if (height > MAX_HEIGHT) {
                                width *= MAX_HEIGHT / height;
                                height = MAX_HEIGHT;
                            }
                        }

                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);

                        canvas.toBlob(
                            (blob) => {
                                if (blob) {
                                    resolve(blob);
                                } else {
                                    reject(new Error('Canvas to Blob conversion failed.'));
                                }
                            },
                            MIME_TYPE,
                            QUALITY
                        );
                    };
                    img.onerror = (error) => reject(error);
                };
                reader.onerror = (error) => reject(error);
                reader.readAsDataURL(file);
            });
        }

        async function submitParagraph() {
            const text = paragraphInput.value.trim();
            const file = bgImageInput.files[0];
            const fontClass = fontSelector.value;

            if (text === "") {
                showMessage("Please write a thought before setting it free.", "orange");
                return;
            }
            
            if (!auth.currentUser) {
                showMessage("You are not connected. Please wait and try again.", "red");
                return;
            }
            const userId = auth.currentUser.uid;

            submitButton.disabled = true;
            submitButtonText.textContent = 'Eternalizing...';

            let imageUrl = null;

            try {
                let fileToUpload = file;
                if (file) {
                    submitButtonText.textContent = 'Processing image...';
                    fileToUpload = await compressImage(file);
                    submitButtonText.textContent = 'Uploading image...';
                }

                if (fileToUpload) {
                    const filePath = `artifacts/${appId}/public/images/${userId}/${Date.now()}-${file.name || 'image.jpg'}`;
                    const storageRef = ref(storage, filePath);
                    const snapshot = await uploadBytes(storageRef, fileToUpload);
                    imageUrl = await getDownloadURL(snapshot.ref);
                }
                
                submitButtonText.textContent = 'Saving thought...';

                const paragraphsCollectionPath = `artifacts/${appId}/public/data/paragraphs`;
                const docData = { 
                    text, 
                    fontClass,
                    createdAt: serverTimestamp(),
                    likes: 0
                };
                if (imageUrl) {
                    docData.imageUrl = imageUrl;
                }

                await addDoc(collection(db, paragraphsCollectionPath), docData);
                
                paragraphInput.value = '';
                bgImageInput.value = '';
                fileNameSpan.textContent = '';
                showMessage("Your thought is now part of eternity.", "green");

            } catch (error) {
                console.error("Submission error:", error);
                showMessage("Your thought could not be saved. Please try again.", "red");
            } finally {
                submitButton.disabled = false;
                submitButtonText.textContent = 'Submit & Eternalize';
            }
        }
        
        function showMessage(text, color) {
            const colorClasses = {
                green: 'text-green-300',
                red: 'text-red-300',
                orange: 'text-amber-300'
            };
            messageBox.textContent = text;
            messageBox.className = `mt-4 text-center font-semibold ${colorClasses[color] || 'text-white'}`;
            setTimeout(() => { messageBox.textContent = ''; }, 4000);
        }

        submitButton.addEventListener('click', submitParagraph);
    </script>
</body>
</html>
